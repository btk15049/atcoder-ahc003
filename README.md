# AtCoder Heuristic Contest 003

https://atcoder.jp/contests/ahc003/tasks/ahc003_a

## 日記

### 5/22

初日

問題文を読んだ感想

- 多腕バンディッドの亜種に見える
  - ~~最初の方のスコアの重みが大きい~~
    - 逆だった、最初のスコアは割とどうでもいいっぽい（最初のほうが大きいほうが面白いと思うけど、、、）
  - 経路の結果から辺の重みの推定値をどう算出するかが難しそう
- なぜかグラフのパターンが 2 種類ある
  - M によって変わる
    - M = 1 なら一列の辺のコストは近い値になる
    - M = 2 なら、一列の辺がある一箇所で二分されて、分割された内部は近い値になる
- ~~WA の条件に同じ頂点を使うことやゴールを通り過ぎることが含まれていない~~
  - 同じ頂点を使ってはいけないと書いてあった、鬼
  - ~~最初の 10 回とかを使ってマップのほぼ全域を探査し、予測値を推定することは可能そう~~
    - ~~M = 1 ならかなり有効、60 回あれば各辺の平均値を出せる、M = 2 の場合は厄介~~
    - ~~この方法をやるかどうかは、最終スコア次第~~
      - ~~最初の 60 回を犠牲にする価値があるかどうか~~
      - ~~200 回目の時点で 60% -> 90% とかにできるならやってもいいのかも~~
      - ~~うまくやれば 1 クエリで 2 列分 探索できるはず~~
        - ~~片方の列を 100 往復、片方の列を 1 往復 とすると、平均値は見えそう~~
- ビジュアライザが見づらい
  - これはポリゴンショックでは、、、
  - ホットスポットみたいなものがあるはずなので、それをうまくブラシとかで表現したい

実装したもの

- ルール通り動かすための道具
- UCB1 っぽいものを使ったバンディットアルゴリズム
  - 辺を 今まで計測できた 推定値 - 期待値 みたいに扱って、それを距離とみなしダイクストラをする
    - 通常の ucb 関数は 勝率 + 期待値 みたいな形になるはずなので、少し形が違う
    - 期待値の計算は雑に 500 ぐらいをかける
  - もっとちゃんと推定をしたい

### 5/23

気づいたこと

- ジャッジから返ってくるのは正確な数値じゃないことに気づく
  - 連立方程式使うの意味なくない？
- 公式ツールを書き換えて、推定値と実際の数値の乖離を出力するようにしたい
  - Rust 読めません、無理！
    - 気合で書き換えた
- デバッグモードを実装して、推定値と解を出力してみたところ、かなりの乖離があることがわかった
  - 連立方程式がたくさん与えられるので、式をうまくあてはめて誤差を最小化してくださいという問題にしたい
    - 最小二乗法。。。

### 5/24

やったこと

- パラメータ推定の知識が足りない
  - 最小二乗法は立式を間違えたのかサンプルが足りないのかで失敗した
- 雑に平均を求めて、その平均から平均を取るみたいな形で実装したらある程度マシになった
  - でも推定値と実際の値の 差 は平均 1000 ぐらいあるっぽいのでなんとかしなくてはいけない
- ツールの方に改修を加えて、各ターンのスコアと一緒に最終 10, 50, 100 ターンのスコア平均も出すようにしてみた
  - 基本的には増加傾向で、最終的に 96 % ぐらいまであがるんだけど、途中から平均が下がったりする、なんでかは正直あんまりわからない。。。
    - これが 98 を超えないと 1 位相当は狙えないので、そこは精度の問題か
  - 95 % に上がるまでに 500 turn ぐらい要していて流石に遅い
- 最初 50 手ぐらいは探索フェーズとしてもっと手を使うようにしてもいいかも
  - ルール的に ucb1 は弱いかも？

### 5/25

やったこと

- テストケースの生成方法に合わせて、行単位、列単位でコストが近いものとして推定できるようにロジックを変更した
  - オレオレパラメータ推定の合間に、行、列ごとに推定値を平滑化するようにする処理を無理やり入れて対処した
    - 行単位、列単位で 1 変数として最小二乗法とかもできるかも、現状はやらなくていいかなとも思っているけど、、、
  - 最終ターンあたりで 96 % ぐらいだったのが 98 % ぐらいまで上昇するようになった、立ち上がり（100 ターンあたり）の数値も 90% ぐらいになっていて悪くない
- ucb1 は弱いかもという仮定のもと、AB テストチックに最初にランダムウォークする処理を入れてみた
  - これは失敗で、多くの辺を均等に使うような処理は無駄が多いという事がわかった
    - 多くの辺（あるいは行、列）を使うとペナルティを与えるような関数をコストに使うといいかも
      - 現状は推定距離 - ucb の期待値
- そろそろパラメータ最適化をしたい気持ちになってきた
- M=1, M=2 でどのくらい傾向が変わるか気になり始めたので、generator を弄って別々のディレクトリにテストケースが入るようにした
  - ↑ の改善を入れた結果か、M=1 のケースでは 95 % ぐらい出るようになっているが、M=2 のケースが弱いままなことがわかった
- AtCoder に generator を改変したものを GitHub で公開していいか確認した
  - 公開するのが目的というよりは純粋に同じリポジトリで管理したかった
  - OK という返事を秒でいただいた、thx

### 5/26

- Optuna の最適化を入れた
  - UCB1 のバイアスをチューニングしてもらうようにしたらスコアが少し上がった、いい感じ
  - グラフの作り方とかを覚えた
- 各行（列）を半々で区切って平滑化するようにしたら強くなった
  - その他バグっていた部分を直したら 95.6/7 ぐらいまで上がるようになった
    - 200 ケースで 96 出るので、システスはもう少し上がるはず
  - M = 1 で 96.7 ぐらい、 M = 2 で　 95.3 ぐらい
  - 区切り位置を雑に探索するやつをやってみたが、あまりうまくいかなかった
- 乱択で辺を選んで、推定値の精度がよくなるように偏微分とかしてもよさそう
  - 三分探索ができるはず

## コマンド

### 公式ツールを DL

```bash
wget -O tester.zip "https://img.atcoder.jp/ahc003/c1ae4a8996958aa31f5f9d3aa3f51033.zip"
unzip tester.zip
```
