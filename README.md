# AtCoder Heuristic Contest 003

https://atcoder.jp/contests/ahc003/tasks/ahc003_a

## 日記

### 5/22

初日

問題文を読んだ感想

- 多腕バンディッドの亜種に見える
  - ~~最初の方のスコアの重みが大きい~~
    - 逆だった、最初のスコアは割とどうでもいいっぽい（最初のほうが大きいほうが面白いと思うけど、、、）
  - 経路の結果から辺の重みの推定値をどう算出するかが難しそう
- なぜかグラフのパターンが 2 種類ある
  - M によって変わる
    - M = 1 なら一列の辺のコストは近い値になる
    - M = 2 なら、一列の辺がある一箇所で二分されて、分割された内部は近い値になる
- ~~WA の条件に同じ頂点を使うことやゴールを通り過ぎることが含まれていない~~
  - 同じ頂点を使ってはいけないと書いてあった、鬼
  - ~~最初の 10 回とかを使ってマップのほぼ全域を探査し、予測値を推定することは可能そう~~
    - ~~M = 1 ならかなり有効、60 回あれば各辺の平均値を出せる、M = 2 の場合は厄介~~
    - ~~この方法をやるかどうかは、最終スコア次第~~
      - ~~最初の 60 回を犠牲にする価値があるかどうか~~
      - ~~200 回目の時点で 60% -> 90% とかにできるならやってもいいのかも~~
      - ~~うまくやれば 1 クエリで 2 列分 探索できるはず~~
        - ~~片方の列を 100 往復、片方の列を 1 往復 とすると、平均値は見えそう~~
- ビジュアライザが見づらい
  - これはポリゴンショックでは、、、
  - ホットスポットみたいなものがあるはずなので、それをうまくブラシとかで表現したい

実装したもの

- ルール通り動かすための道具
- UCB1 っぽいものを使ったバンディットアルゴリズム
  - 辺を 今まで計測できた 推定値 - 期待値 みたいに扱って、それを距離とみなしダイクストラをする
    - 通常の ucb 関数は 勝率 + 期待値 みたいな形になるはずなので、少し形が違う
    - 期待値の計算は雑に 500 ぐらいをかける
  - もっとちゃんと推定をしたい

### 5/23

気づいたこと

- ジャッジから返ってくるのは正確な数値じゃないことに気づく
  - 連立方程式使うの意味なくない？
- 公式ツールを書き換えて、推定値と実際の数値の乖離を出力するようにしたい
  - Rust 読めません、無理！
    - 気合で書き換えた
- デバッグモードを実装して、推定値と解を出力してみたところ、かなりの乖離があることがわかった
  - 連立方程式がたくさん与えられるので、式をうまくあてはめて誤差を最小化してくださいという問題にしたい
    - 最小二乗法。。。

### 5/24

やったこと

- パラメータ推定の知識が足りない
  - 最小二乗法は立式を間違えたのかサンプルが足りないのかで失敗した
- 雑に平均を求めて、その平均から平均を取るみたいな形で実装したらある程度マシになった
  - でも推定値と実際の値の 差 は平均 1000 ぐらいあるっぽいのでなんとかしなくてはいけない
- ツールの方に改修を加えて、各ターンのスコアと一緒に最終 10, 50, 100 ターンのスコア平均も出すようにしてみた
  - 基本的には増加傾向で、最終的に 96 % ぐらいまであがるんだけど、途中から平均が下がったりする、なんでかは正直あんまりわからない。。。
    - これが 98 を超えないと 1 位相当は狙えないので、そこは精度の問題か
  - 95 % に上がるまでに 500 turn ぐらい要していて流石に遅い
- 最初 50 手ぐらいは探索フェーズとしてもっと手を使うようにしてもいいかも
  - ルール的に ucb1 は弱いかも？

### 5/25

やったこと

- テストケースの生成方法に合わせて、行単位、列単位でコストが近いものとして推定できるようにロジックを変更した
  - オレオレパラメータ推定の合間に、行、列ごとに推定値を平滑化するようにする処理を無理やり入れて対処した
    - 行単位、列単位で 1 変数として最小二乗法とかもできるかも、現状はやらなくていいかなとも思っているけど、、、
  - 最終ターンあたりで 96 % ぐらいだったのが 98 % ぐらいまで上昇するようになった、立ち上がり（100 ターンあたり）の数値も 90% ぐらいになっていて悪くない
- ucb1 は弱いかもという仮定のもと、AB テストチックに最初にランダムウォークする処理を入れてみた
  - これは失敗で、多くの辺を均等に使うような処理は無駄が多いという事がわかった
    - 多くの辺（あるいは行、列）を使うとペナルティを与えるような関数をコストに使うといいかも
      - 現状は推定距離 - ucb の期待値
- そろそろパラメータ最適化をしたい気持ちになってきた
- M=1, M=2 でどのくらい傾向が変わるか気になり始めたので、generator を弄って別々のディレクトリにテストケースが入るようにした
  - ↑ の改善を入れた結果か、M=1 のケースでは 95 % ぐらい出るようになっているが、M=2 のケースが弱いままなことがわかった
- AtCoder に generator を改変したものを GitHub で公開していいか確認した
  - 公開するのが目的というよりは純粋に同じリポジトリで管理したかった
  - OK という返事を秒でいただいた、thx

### 5/26

- Optuna によるパラメータの最適化を入れた
  - UCB1 のバイアスをチューニングしてもらうようにしたらスコアが少し上がった、いい感じ
  - グラフの作り方とかを覚えた
- 各行（列）を半々で区切って平滑化するようにしたら強くなった
  - その他バグっていた部分を直したら 95.6/7 ぐらいまで上がるようになった
    - 200 ケースで 96 出るので、システスはもう少し上がるはず
  - M = 1 で 96.7 ぐらい、 M = 2 で 95.3 ぐらい
  - 区切り位置を雑に探索するやつをやってみたが、あまりうまくいかなかった
- 乱択で辺を選んで、推定値の精度がよくなるように偏微分とかしてもよさそう
  - 三分探索ができるはず

### 5/27

- Optuna の枝化りオプションが効かない理由がわかった
  - 公式の Doc に書いてあったが、枝刈りするかどうかの判定が必要っぽい
- M = 2 のときの区切り位置を探索するロジックを入れてみた
  - ひとまず分散を使ってみることに
- 区切り位置を一度推定値として決めてしまうと、その後の探索で推定値がそこに固定されてしまう問題があった
  - ランダムで無理やり中央に近づけるみたいなことをしてみた
    - 本当はもうちょっと違ったずらし方のほうがいいかもしれない
- M = 1 / 2 を分類できたら強いかもしれない

### 5/28

- 偏微分ロジックを焼きなましみたいに使えないか試してみたくなった
  - 遅すぎるので高速化が必要そう
  - ダメだった、そもそも弱い
- 全体平滑化ロジックについて、ランダムフォレストみたいに計算に使うクエリをランダム化できないか
  - 数値が変わることによる分散値計算の最適化を狙う
  - ダメだった、理由はわからないけれど弱い
- 分割位置推定を無理やり中央に近づけるようにしていた部分を、ランダムな位置に近づけるようにしたらまあまあスコアが上がった
  - ここが焼きなましチックになっているんだと思う
  - 温度管理をしてもよいかも
- 後半はあまりループ回数がいらないはずなので、気合で生成した温度関数 cwwFunction を使ってループ回数を節約した
  - システス時の TLE への懸念を解消

### 5/29

- 分割位置の分布で M=1 と M=2 を推定できたりしないか
  - できたところで、上がっても 1g 程度か
  - 得点分布でやってもいいかも
- 分割位置推定の強制変更ロジックをいじってみたが、あまりよくならなかった
  - 今とどの程度離れているかで確率を変えたり
  - 移動距離に時間を加味してみたりしてもダメだった
- 公式の visualizer を見ると、 D がでかいときに弱いのがわかった
  - 偏微分ロジックを入れて誤魔化すことにした
    - 94 を下回るようなケースはなくなった

### 5/30

- 偏微分ロジックについて、大きい差のものを減らすように動くのはどうか
  - 軽くやってみたけど難しそう
- 期待距離として、辺自体の評価回数を加えるのはどうか
  - 試す価値あり

## コマンド

### 公式ツールを DL

```bash
wget -O tester.zip "https://img.atcoder.jp/ahc003/c1ae4a8996958aa31f5f9d3aa3f51033.zip"
unzip tester.zip
```

### 逐次実行

1 スレッドで順番に実行
あんまり使わない

```bash
fish scripts/straight.fish
```

### 並列実行

基本は 2 秒おきに 10 スレッド起動
第一引数で並列数、第二引数でインターバルを調整できる

```bash
fish scripts/parallel.fish
```

### デバッグ実行

並列実行と同じだが、デバッグ出力をディレクトリに出す

```bash
fish scripts/debug.fish
```

## 細かい Tips

fish スクリプト内で実行スクリプトが存在するディレクトリを取得する

```fish
dirname (readlink -m (status --current-filename)))
```

fish は日本語記事が少なくて検索が大変
